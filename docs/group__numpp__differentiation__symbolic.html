<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>numpp: Symbolic Differentiation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">numpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Symbolic Differentiation<div class="ingroups"><a class="el" href="group__numpp__differentiation.html">Differentiation</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This module provides the means for performing symbolic differentiation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpp_1_1differentiation_1_1symbolic_1_1differentiate.html">numpp::differentiation::symbolic::differentiate&lt; Function, Order &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows differentiation of N-th order.  <a href="classnumpp_1_1differentiation_1_1symbolic_1_1differentiate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpp_1_1differentiation_1_1symbolic_1_1constant.html">numpp::differentiation::symbolic::constant&lt; Value &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing constant integer number.  <a href="classnumpp_1_1differentiation_1_1symbolic_1_1constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpp_1_1differentiation_1_1symbolic_1_1variable.html">numpp::differentiation::symbolic::variable&lt; T, Number &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing variable of any type.  <a href="classnumpp_1_1differentiation_1_1symbolic_1_1variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac865497d2896f51d0cab2e9c64799a15"><td class="memTemplParams" colspan="2"><a id="gac865497d2896f51d0cab2e9c64799a15"></a>
template&lt;std::size_t Number&gt; </td></tr>
<tr class="memitem:gac865497d2896f51d0cab2e9c64799a15"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numpp__differentiation__symbolic.html#gac865497d2896f51d0cab2e9c64799a15">numpp::differentiation::symbolic::x</a> = <a class="el" href="classnumpp_1_1differentiation_1_1symbolic_1_1variable.html">variable</a>&lt; double, Number &gt;</td></tr>
<tr class="memdesc:gac865497d2896f51d0cab2e9c64799a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for variable with specified variable type as double. <br /></td></tr>
<tr class="separator:gac865497d2896f51d0cab2e9c64799a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga186ca63e28a816d1cb9c8175c7839468"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga186ca63e28a816d1cb9c8175c7839468"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numpp__differentiation__symbolic.html#ga186ca63e28a816d1cb9c8175c7839468">numpp::differentiation::symbolic::log</a> (const T &amp;)</td></tr>
<tr class="separator:ga186ca63e28a816d1cb9c8175c7839468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad414fd158986bf7fff7e258a6ebf182c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad414fd158986bf7fff7e258a6ebf182c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numpp__differentiation__symbolic.html#gad414fd158986bf7fff7e258a6ebf182c">numpp::differentiation::symbolic::cos</a> (const T &amp;)</td></tr>
<tr class="separator:gad414fd158986bf7fff7e258a6ebf182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45bd7508b366431d72157d0f1ef6fac2"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga45bd7508b366431d72157d0f1ef6fac2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numpp__differentiation__symbolic.html#ga45bd7508b366431d72157d0f1ef6fac2">numpp::differentiation::symbolic::operator+</a> (const Left &amp;, const Right &amp;)</td></tr>
<tr class="separator:ga45bd7508b366431d72157d0f1ef6fac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aecf7125ae67f3c834ed8ab5e14248a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4aecf7125ae67f3c834ed8ab5e14248a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numpp__differentiation__symbolic.html#ga4aecf7125ae67f3c834ed8ab5e14248a">numpp::differentiation::symbolic::operator-</a> (const T &amp;)</td></tr>
<tr class="separator:ga4aecf7125ae67f3c834ed8ab5e14248a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f6f3d22e3e712ce154f7f6c91e0cf46"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga0f6f3d22e3e712ce154f7f6c91e0cf46"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numpp__differentiation__symbolic.html#ga0f6f3d22e3e712ce154f7f6c91e0cf46">numpp::differentiation::symbolic::operator*</a> (const Left &amp;, const Right &amp;)</td></tr>
<tr class="separator:ga0f6f3d22e3e712ce154f7f6c91e0cf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac882bc2dcbffae1107c46bc3eac93a44"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gac882bc2dcbffae1107c46bc3eac93a44"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numpp__differentiation__symbolic.html#gac882bc2dcbffae1107c46bc3eac93a44">numpp::differentiation::symbolic::operator/</a> (const Left &amp;, const Right &amp;)</td></tr>
<tr class="separator:gac882bc2dcbffae1107c46bc3eac93a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52e3714ea3492f60c68cdb4974fe495"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Left &gt; </td></tr>
<tr class="memitem:gaa52e3714ea3492f60c68cdb4974fe495"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numpp__differentiation__symbolic.html#gaa52e3714ea3492f60c68cdb4974fe495">numpp::differentiation::symbolic::pow</a> (const Left &amp;)</td></tr>
<tr class="separator:gaa52e3714ea3492f60c68cdb4974fe495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcf2dcdbc549b58c9fb7cd1b8c1cf70"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4bcf2dcdbc549b58c9fb7cd1b8c1cf70"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numpp__differentiation__symbolic.html#ga4bcf2dcdbc549b58c9fb7cd1b8c1cf70">numpp::differentiation::symbolic::exp</a> (const T &amp;)</td></tr>
<tr class="separator:ga4bcf2dcdbc549b58c9fb7cd1b8c1cf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ba3eed5ff463e79a88f4952f73f435"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga49ba3eed5ff463e79a88f4952f73f435"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numpp__differentiation__symbolic.html#ga49ba3eed5ff463e79a88f4952f73f435">numpp::differentiation::symbolic::sin</a> (const T &amp;)</td></tr>
<tr class="separator:ga49ba3eed5ff463e79a88f4952f73f435"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module provides the means for performing symbolic differentiation. </p>
<div class="fragment"><div class="line"><a class="code" href="namespacenumpp.html">numpp</a>/differentiation/symbolic.hpp #includes every method in the module</div><div class="line"><a class="code" href="namespacenumpp.html">numpp</a>/differentiation/symbolic/SUBCLASS.hpp #include specific SUBCLASS</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd><b>Second include option SHOULDN'T be used</b></dd></dl>
<p>Idea developed independently, but merged with the research paper <a href="https://arxiv.org/abs/1705.01729">Compile Time Symbolical Differentiation 2017</a> and many ideas based on theirs. <br />
<b>Thank you for this paper, most of the credits belong to them! Please refer to their paper for thourough speed comparison against automatic differentiation.</b></p>
<p>For differences mine and theirs application of the type differentiation see this paper: <a href="https://github.com">numpp dissertation </a> <br />
 For comparison against <a href="https://github.com/symengine/symengine">symengine</a>, base of <a href="http://www.sympy.org/en/index.html">SymPy</a> see these tests: <a href="https://github.com">sympy vs numpp </a></p>
<p><b>Details and usage:</b></p>
<p>Overloads for common mathemathical operations are provided (details in classes).<br />
Approach taken by type differentiating doesn't resemble well-known symbolic differentiation in C++, hence some examples are needed:</p>
<dl class="section warning"><dt>Warning</dt><dd>For convenience, in the following examples, namespace numpp::differentiation::symbolic is abbreviated as nds.</dd></dl>
<p><b>1. Variables and constants </b></p>
<p>Basing building blocks of the function. Can be defined as follows: </p><div class="fragment"><div class="line"><a class="code" href="classnumpp_1_1differentiation_1_1symbolic_1_1variable.html">nds::x&lt;0&gt;</a> x0{};</div><div class="line"><a class="code" href="classnumpp_1_1differentiation_1_1symbolic_1_1variable.html">nds::x&lt;1&gt;</a> x1{};</div></div><!-- fragment --><p>Above x variables are implicilty of type double. To express type explicitly use:</p>
<div class="fragment"><div class="line"><a class="code" href="classnumpp_1_1differentiation_1_1symbolic_1_1variable.html">nds::variable&lt;int, 0&gt;</a> x0{};</div></div><!-- fragment --><p>Numeric parameter (of type std::size_t) differentiates every variable from the others.</p>
<div class="fragment"><div class="line"><a class="code" href="classnumpp_1_1differentiation_1_1symbolic_1_1constant.html">nds::constant&lt;14&gt;</a> cons{};</div></div><!-- fragment --><p>Currently only integer constants are supported.</p>
<p><b>2. Defining functions </b></p>
<p>We only have to define Function type, there is no need to create the object.<br />
Arithmetic operators and some other mathematical functions are overloaded for convenience in function defining.</p>
<p>You should use the</p><div class="fragment"><div class="line"><span class="keyword">using</span> and decltype() </div></div><!-- fragment --><p> when defining it.</p>
<p><b>Example of <img class="formulaInl" alt="$ \sin(\cos(\frac{x_0}{x_1})*\log(x_0)) + x_2 $" src="form_18.png"/> creation</b> :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include&quot;numpp/differentiation/symbolic.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Function = decltype(<a class="code" href="group__numpp__differentiation__forward__automatic.html#ga6f6f07250087b18ada9ea1f84418f24f">sin</a>(<a class="code" href="group__numpp__differentiation__forward__automatic.html#gaa5a06320f93037d94fda441546d7d690">cos</a>(<a class="code" href="classnumpp_1_1differentiation_1_1symbolic_1_1variable.html">nds::x&lt;0&gt;</a>{}/<a class="code" href="classnumpp_1_1differentiation_1_1symbolic_1_1variable.html">nds::x&lt;1&gt;</a>{})*<a class="code" href="group__numpp__differentiation__forward__automatic.html#ga0f6011595edffe756a984de60358fe5f">log</a>(<a class="code" href="classnumpp_1_1differentiation_1_1symbolic_1_1variable.html">nds::x&lt;0&gt;</a>{})) + <a class="code" href="classnumpp_1_1differentiation_1_1symbolic_1_1variable.html">nds::x&lt;2&gt;</a>{});</div></div><!-- fragment --><p><b>3. Differentiating the function:</b></p>
<p>There are two ways to differentiate type, as shown below:</p>
<p><b>3.1. Predicate with_respect_to:</b> </p><div class="fragment"><div class="line"><span class="comment">//Function as defined above</span></div><div class="line"><span class="keyword">using</span> Derivative = <a class="code" href="classnumpp_1_1differentiation_1_1symbolic_1_1differentiate.html">nds::differentiate&lt;Function, 3&gt;::with_respect_to</a>&lt;0,0,1&gt;;</div></div><!-- fragment --><p>Above code performs 3-rd order differentiation with respect to <img class="formulaInl" alt="$x_0, x_0, x_1 $" src="form_19.png"/> in this exact order.</p>
<p><b>3.2. With derivative type:</b> </p><div class="fragment"><div class="line"><span class="comment">//Function as defined above</span></div><div class="line"><span class="keyword">using</span> Derivative = Function::derivative&lt;0&gt;</div></div><!-- fragment --><p>Above performs differentiation with respect to <img class="formulaInl" alt="$x_0$" src="form_20.png"/>.</p>
<p><b>4. Obtaining numerical values from expressions</b></p>
<p>After obtaining Function type (or Derivative or similiar) you would probably like to obtain value at a given point. <br />
To do so, you have to create an array which size is equal to the number of independent variables<br />
and pass it to the static constexpr function <b>calculate</b></p>
<p><b>Example</b></p>
<div class="fragment"><div class="line"><span class="comment">//Derivative as defined above</span></div><div class="line">constexpr <span class="keyword">auto</span> value = Derivative::calculate(std::array&lt;double, 3&gt;{1.,5.,7.});</div></div><!-- fragment --><p>Any object providing operator[] may be used as an argument to calculate.</p>
<p><b>Technical Details:</b></p>
<p>Approach of type differentiating allows this module to obtain near hand-coded efficiency for n-th order partial derivatives.</p>
<p>Cons - compilation may take longer as order and complexity of formula increases after this initial phase, every derivative evaluation or next differentiation will take substantially shorter amount of time than current available approaches. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad414fd158986bf7fff7e258a6ebf182c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad414fd158986bf7fff7e258a6ebf182c">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto numpp::differentiation::symbolic::cos </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>cos returns object representing <img class="formulaInl" alt="$ \cos(T) $" src="form_17.png"/> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Parameter representing type of the argument (can be complex like log(x))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type representing <img class="formulaInl" alt="$ \cos(T) $" src="form_17.png"/></dd></dl>

</div>
</div>
<a id="ga4bcf2dcdbc549b58c9fb7cd1b8c1cf70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bcf2dcdbc549b58c9fb7cd1b8c1cf70">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto numpp::differentiation::symbolic::exp </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>exp returns object representing <img class="formulaInl" alt="$ e^T $" src="form_14.png"/> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Parameter representing type of the exponent (can be complex like sin(x))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type representing <img class="formulaInl" alt="$ e^T $" src="form_14.png"/></dd></dl>

</div>
</div>
<a id="ga186ca63e28a816d1cb9c8175c7839468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga186ca63e28a816d1cb9c8175c7839468">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto numpp::differentiation::symbolic::log </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>log returns object representing <img class="formulaInl" alt="$ \log(T) $" src="form_15.png"/> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Parameter representing type being logarithmized (can be complex like sin(x))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type representing <img class="formulaInl" alt="$ \log(T) $" src="form_15.png"/></dd></dl>

</div>
</div>
<a id="ga0f6f3d22e3e712ce154f7f6c91e0cf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f6f3d22e3e712ce154f7f6c91e0cf46">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto numpp::differentiation::symbolic::operator* </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>operator* returns object representing multiplication of Left and Right hand-side </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>Parameter representing left hand-side (can be complex like sin(x)) </td></tr>
    <tr><td class="paramname">Right</td><td>Parameter representing Right hand-side (can be complex like sin(x))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type representing multiplication of Left and Right</dd></dl>

</div>
</div>
<a id="ga45bd7508b366431d72157d0f1ef6fac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45bd7508b366431d72157d0f1ef6fac2">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto numpp::differentiation::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>operator+ returns object representing addition of Left and Right hand-side </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>Parameter representing left hand-side (can be complex like sin(x)) </td></tr>
    <tr><td class="paramname">Right</td><td>Parameter representing Right hand-side (can be complex like sin(x))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type representing addition of Left and Right</dd></dl>

</div>
</div>
<a id="ga4aecf7125ae67f3c834ed8ab5e14248a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4aecf7125ae67f3c834ed8ab5e14248a">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto numpp::differentiation::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>operator- returns object representing the negative of it, e.g. sin(x)-&gt; -sin(x) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Parameter representing any type (can be complex like sin(x))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type representing negative of a given object</dd></dl>

</div>
</div>
<a id="gac882bc2dcbffae1107c46bc3eac93a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac882bc2dcbffae1107c46bc3eac93a44">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto numpp::differentiation::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>operator/ returns object representing division of Left and Right hand-side </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>Parameter representing left hand-side (can be complex like sin(x)) </td></tr>
    <tr><td class="paramname">Right</td><td>Parameter representing Right hand-side (can be complex like sin(x))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type representing division of Left and Right</dd></dl>

</div>
</div>
<a id="gaa52e3714ea3492f60c68cdb4974fe495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa52e3714ea3492f60c68cdb4974fe495">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Left &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto numpp::differentiation::symbolic::pow </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns object representing Left hand-side to the n-th power</p>
<p><b>Example usage:</b> </p><div class="fragment"><div class="line"><span class="keyword">using</span> Function = decltype(pow&lt;4&gt;(<a class="code" href="classnumpp_1_1differentiation_1_1symbolic_1_1variable.html">nds::x&lt;0&gt;</a>{}));</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Unluckily there seems to be no workaround around passing exponent as a template parameter</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Power of the function, Left is taken to the power of N </td></tr>
    <tr><td class="paramname">Right</td><td>Parameter representing type being any valid symbolic expression (can be complex like sin(x))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type representing <img class="formulaInl" alt="$ Left^N $" src="form_13.png"/></dd></dl>

</div>
</div>
<a id="ga49ba3eed5ff463e79a88f4952f73f435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49ba3eed5ff463e79a88f4952f73f435">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto numpp::differentiation::symbolic::sin </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sin returns object representing <img class="formulaInl" alt="$ \sin(T) $" src="form_16.png"/> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Parameter representing type of the argument (can be complex like log(x))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type representing <img class="formulaInl" alt="$ \sin(T) $" src="form_16.png"/></dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
