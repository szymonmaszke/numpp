In file included from foo.cpp:1:0:
conjugate_gradient.hpp: In instantiation of ‘constexpr auto numpp::krylov::conjugate_gradient(const numpp::matrix::normal<T, Size, Size>&, const numpp::vector<U, Size, false>&, const numpp::vector<U, Size, false>&, std::size_t) [with T = double; U = double; long unsigned int Size = 2; std::size_t = long unsigned int]’:
foo.cpp:8:60:   required from here
conjugate_gradient.hpp:20:43: error: no match for ‘operator/’ (operand types are ‘std::common_type_t<double, double> {aka double}’ and ‘numpp::vector<numpp::vector<double, 2>, 2, true>’)
           (transpose(residual) * residual)/
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
             (transpose(direction) * (A * direction))};
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from ../structures/vector/vector_functions.hpp:4:0,
                 from ../structures/vector.hpp:4,
                 from ../structures/matrix_vector_operations.hpp:4,
                 from conjugate_gradient.hpp:4,
                 from foo.cpp:1:
../structures/vector/vector_operations.hpp:124:18: note: candidate: template<class T, class U, long unsigned int Size, bool Transposition> constexpr auto numpp::operator/(const numpp::vector<T, Size, Transposition>&, U)
   constexpr auto operator/(
                  ^~~~~~~~
../structures/vector/vector_operations.hpp:124:18: note:   template argument deduction/substitution failed:
In file included from foo.cpp:1:0:
conjugate_gradient.hpp:20:43: note:   mismatched types ‘const numpp::vector<T, Size, Transposition>’ and ‘std::common_type_t<double, double> {aka double}’
           (transpose(residual) * residual)/
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
             (transpose(direction) * (A * direction))};
             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
conjugate_gradient.hpp:19:20: error: unable to deduce ‘const auto’ from ‘<expression error>’
         const auto alpha {
                    ^~~~~
